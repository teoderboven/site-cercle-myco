/**
 * Creates an HTML element with attributes
 * @param {string} tagName The name of the HTML element tag to create
 * @param {Object} attributes The attributes of the element as a key-value object
 * @returns {HTMLElement} The created HTML element with the specified attributes
 * @note generated by ChatGPT
 */
function createElementWithAttributes(tagName, attributes) {
	const element = document.createElement(tagName);
	for (var attr in attributes) {
		element.setAttribute(attr, attributes[attr]);
	}
	return element;
}
(function(){
	/*
	 * Init the viewer
	 */
	const viewerWraper = createElementWithAttributes('div', {id: 'viewerWraper'});
	const viewerBg = createElementWithAttributes('div', {id: 'viewerBg'});
	const viewerContainer = createElementWithAttributes('div', { id: 'viewerContainer'});
	const navLeft = createElementWithAttributes('div', {class: 'viewerNav left'});
	const buttonLeft = createElementWithAttributes('button', {title: "Image précédente (flèche gauche)"});
	const spanLeft = createElementWithAttributes('span');
	const imageSection = createElementWithAttributes('section', {class: 'image'});
	const navRight = createElementWithAttributes('div', {class: 'viewerNav right'});
	const buttonRight = createElementWithAttributes('button', {title: "Image suivante (flèche droite)"});
	const spanRight = createElementWithAttributes('span');
	const viewerButtons = createElementWithAttributes('div', {id: 'viewerButtons'});
	const closeButton = createElementWithAttributes('button', {id: 'close', title: "Fermer (Echap)"});
	const fullscreenButton = createElementWithAttributes('button', {id: 'fullscreen', title: "Basculer en plein écran (f)"});
	
	buttonLeft.appendChild(spanLeft);
	navLeft.appendChild(buttonLeft);
	
	buttonRight.appendChild(spanRight);
	navRight.appendChild(buttonRight);
	
	viewerContainer.appendChild(navLeft);
	viewerContainer.appendChild(imageSection);
	viewerContainer.appendChild(navRight);
	
	viewerButtons.appendChild(closeButton);
	viewerButtons.appendChild(fullscreenButton);
	
	viewerWraper.appendChild(viewerBg);
	viewerWraper.appendChild(viewerContainer);
	viewerWraper.appendChild(viewerButtons);
	
	document.body.appendChild(viewerWraper);

	////////////////////////////////////////////////////////////////////////////////////////////////////////

	var fullscreenWhenOpen; // determines if the document is fullscreen when the preview is open
	
	/**
	 * Opens the viewer
	 */
	function openViewer(){
		viewerWraper.classList.add('visible');
		document.body.classList.add('no-scroll');
	}
	/**
	 * Closes the viewer
	 */
	function closeViewer(){
		viewerWraper.classList.remove('visible');
		document.body.classList.remove('no-scroll');
		if(!fullscreenWhenOpen && isViewerFullscreen()){
			exitFullscreen();
		}
	}
	/**
	 * Determines if the viewer is open
	 * @returns {boolean} true if the viewer is open, false else
	 */
	function isViewerOpen(){
		return viewerWraper.classList.contains('visible');
	}
	/**
	 * Determines if the viewer is full screen
	 * @returns {boolean} true if the viewer is full screen, false else
	 */
	function isViewerFullscreen(){
		if(document.webkitFullscreenElement)
			return document.webkitFullscreenElement === viewerWraper;
		else if(document.mozFullScreenElement)
			return document.mozFullScreenElement === viewerWraper;
		else if(document.msFullscreenElement)
			return document.msFullscreenElement === viewerWraper;
		else
			return document.fullscreenElement === viewerWraper;
	}
	/**
	 * Takes the document out of full screen mode (considers prefixes)
	 */
	function exitFullscreen(){
		console.log('oui')
		if (document.exitFullscreen)
			document.exitFullscreen();
		else if (document.webkitExitFullscreen)
			document.webkitExitFullscreen();
		else if (document.mozCancelFullScreen)
			document.mozCancelFullScreen();
		else if (document.msExitFullscreen)
			document.msExitFullscreen();		  
	}
	/**
	 * Switches the fullscreen state of the viewer
	 */
	function switchFullscreen(){
		if(isViewerFullscreen()){
			exitFullscreen();
		}else{
			if (viewerWraper.requestFullscreen)
				viewerWraper.requestFullscreen();
			else if (viewerWraper.webkitRequestFullscreen)
				viewerWraper.webkitRequestFullscreen();
			else if (viewerWraper.mozRequestFullScreen)
				viewerWraper.mozRequestFullScreen();
			else if (viewerWraper.msRequestFullscreen)
				viewerWraper.msRequestFullscreen();
			else if (viewerWraper.webkitEnterFullscreen)
				viewerWraper.webkitEnterFullscreen();
		}
	}
	/**
	 * Correctly displays navigation buttons based on context
	 * @param {number} id the current image id
	 * @param {NodeList} list the list of images viewable
	 */
	function displayNav(id, list){
		navLeft.classList.remove('disable');
		navRight.classList.remove('disable');
		if(id < 1){
			navLeft.classList.add('disable');
		}
		if(id > list.length-2){
			navRight.classList.add('disable');
		}
	}

	// Init events /////////////////////////////////////////////////////
	const viewable = document.querySelectorAll('.image.viewable');
	var currentId;

	/**
	 * Displays the previous image in the viewer
	 */
	function previousImage(){
		if(currentId-1 < 0) return;
		imageSection.innerHTML = viewable.item(--currentId).innerHTML;
		displayNav(currentId, viewable);
	}
	/**
	 * Displays the next image in the viewer
	 */
	function nextImage(){
		if(currentId+1 >= viewable.length) return;
		imageSection.innerHTML = viewable.item(++currentId).innerHTML;
		displayNav(currentId, viewable);
	}

	viewable.forEach((elt, id)=>{ // open viewer when click on an image <----------------------
		elt.addEventListener('click', ()=>{
			currentId = id;
			fullscreenWhenOpen = !!document.fullscreenElement;
			
			imageSection.innerHTML = elt.innerHTML;
			
			displayNav(id, viewable);
			openViewer();
		});
	});
	// navigation
	navLeft.addEventListener('click', previousImage);
	navRight.addEventListener('click', nextImage);
	document.addEventListener('keydown', (e)=>{
		if(!isViewerOpen()) return;
		switch(e.key){
			case 'ArrowLeft':
			case 'j':
			case 'J':
				previousImage();
				break;
			case 'ArrowRight':
			case 'l':
			case 'L':
				nextImage();
				break;
			case 'f':
			case 'F':
				switchFullscreen();
				break;
			case 'Escape':
				closeViewer();
				break
		}
	});
	// detect swipe      [ChatGPT]
	let touchStartX = 0;
	let touchEndX = 0;

	function handleTouchStart(event) {
		touchStartX = event.touches[0].clientX;
	}
	function handleTouchEnd(event) {
		touchEndX = event.changedTouches[0].clientX;
		handleSwipe();
	}
	function handleSwipe() {
		const swipeThreshold = 50; // Horizontal travel threshold to consider as a swipe

		if(touchEndX - touchStartX > swipeThreshold){ // right swipe
			previousImage();
		}else if(touchStartX - touchEndX > swipeThreshold){ // left swipe
			nextImage();
		}
	}
	viewerWraper.addEventListener('touchstart', handleTouchStart);
	viewerWraper.addEventListener('touchend', handleTouchEnd);

	// close
	closeButton.addEventListener('click', closeViewer);
	viewerBg.addEventListener('click', closeViewer);
	// fullscreen
	fullscreenButton.addEventListener('click', switchFullscreen);
})();